#include <Wire.h>
#include <Adafruit_MPU6050.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_NeoPixel.h>

#include "model_params.h"  // Generated by python/train_model.py

/**
 * PillowMate Action Recognition Inference Sketch
 *
 * Reads Velostat pressure + IMU data, extracts a simple feature vector, and
 * feeds it into the lightweight logistic regression model compiled into
 * model_params.h. The predicted interaction label is printed over Serial and
 * optionally displayed via a NeoPixel strip for quick debugging.
 */

constexpr int kPressurePin = A0;
constexpr uint8_t kNeoPixelPin = 9;
constexpr uint8_t kNeoPixelCount = 8;
constexpr bool kUseNeoPixel = true;

constexpr size_t kSmoothingWindow = 8;  // Number of samples per prediction
constexpr uint16_t kSampleDelayMs = 15;
constexpr uint16_t kPredictionIntervalMs = 150;

Adafruit_MPU6050 imu;
Adafruit_NeoPixel pixels(kNeoPixelCount, kNeoPixelPin, NEO_GRB + NEO_KHZ800);

float featureAccumulator[kFeatureCount] = {0};
size_t accumulatorCount = 0;

unsigned long lastPredictionMs = 0;
int lastPrediction = -1;

float pressureBaseline = 0.f;

void waitForSerial() {
  while (!Serial) {
    delay(10);
  }
}

void initNeoPixel() {
  if (!kUseNeoPixel) {
    return;
  }
  pixels.begin();
  pixels.show();
  pixels.setBrightness(32);
}

void setNeoPixelColor(uint32_t color) {
  if (!kUseNeoPixel) {
    return;
  }
  for (uint8_t i = 0; i < kNeoPixelCount; ++i) {
    pixels.setPixelColor(i, color);
  }
  pixels.show();
}

uint32_t colorForLabel(int labelIdx) {
  switch (labelIdx) {
    case 0:  // tap
      return pixels.Color(0, 150, 255);
    case 1:  // rest_head
      return pixels.Color(0, 255, 128);
    case 2:  // hug
      return pixels.Color(255, 0, 90);
    case 3:  // shake
      return pixels.Color(255, 200, 0);
    default:
      return pixels.Color(10, 10, 10);
  }
}

void configureImu() {
  if (!imu.begin()) {
    Serial.println(F("ERROR: Failed to find IMU. Check wiring."));
    while (true) {
      delay(100);
    }
  }
  imu.setAccelerometerRange(MPU6050_RANGE_8_G);
  imu.setGyroRange(MPU6050_RANGE_500_DEG);
  imu.setFilterBandwidth(MPU6050_BAND_21_HZ);
}

float computePressureDelta(int rawReading) {
  // Convert raw ADC reading into a delta relative to the resting baseline.
  return static_cast<float>(rawReading) - pressureBaseline;
}

void calibratePressureBaseline() {
  Serial.println(F("Calibrating pressure baseline... Keep the pillow idle."));
  const int samples = 200;
  long sum = 0;
  for (int i = 0; i < samples; ++i) {
    sum += analogRead(kPressurePin);
    delay(5);
  }
  pressureBaseline = static_cast<float>(sum) / samples;
  Serial.print(F("Baseline: "));
  Serial.println(pressureBaseline);
}

void accumulateFeatures(const float features[]) {
  for (size_t i = 0; i < kFeatureCount; ++i) {
    featureAccumulator[i] += features[i];
  }
  ++accumulatorCount;
}

bool readyToPredict() {
  const bool haveSamples = accumulatorCount >= kSmoothingWindow;
  const unsigned long now = millis();
  const bool intervalElapsed = (now - lastPredictionMs) >= kPredictionIntervalMs;
  return haveSamples && intervalElapsed;
}

void resetAccumulator() {
  for (size_t i = 0; i < kFeatureCount; ++i) {
    featureAccumulator[i] = 0.f;
  }
  accumulatorCount = 0;
}

void reportPrediction(int labelIdx) {
  const char* label = ActionModuleModel::labelFromIndex(labelIdx);
  Serial.print(F("Prediction: "));
  Serial.println(label);
  setNeoPixelColor(colorForLabel(labelIdx));
}

void setup() {
  Serial.begin(115200);
  waitForSerial();
  pinMode(kPressurePin, INPUT);

  configureImu();
  initNeoPixel();
  calibratePressureBaseline();

  Serial.println(F("PillowMate action-recognition inference ready."));
}

void loop() {
  sensors_event_t accelEvent;
  sensors_event_t gyroEvent;
  sensors_event_t tempEvent;
  imu.getEvent(&accelEvent, &gyroEvent, &tempEvent);

  const int rawPressure = analogRead(kPressurePin);
  const float pressureDelta = computePressureDelta(rawPressure);

  // Feature vector order must match the training data columns.
  float features[kFeatureCount] = {
      pressureDelta,
      accelEvent.acceleration.x,
      accelEvent.acceleration.y,
      accelEvent.acceleration.z,
      gyroEvent.gyro.x,
      gyroEvent.gyro.y,
      gyroEvent.gyro.z,
  };

  accumulateFeatures(features);

  if (readyToPredict()) {
    float averaged[kFeatureCount];
    for (size_t i = 0; i < kFeatureCount; ++i) {
      averaged[i] = featureAccumulator[i] / accumulatorCount;
    }

    const int prediction = ActionModuleModel::predict(averaged);
    if (prediction != lastPrediction) {
      reportPrediction(prediction);
      lastPrediction = prediction;
    }

    lastPredictionMs = millis();
    resetAccumulator();
  }

  delay(kSampleDelayMs);
}
